  name: Generate hotel_sales.json
        env:
          SOURCE_URL: >-
            https://strapi.prod.r53.tablethotels.com/api/hotels-on-sale-page?pagination%5BpageSize%5D=1000&locale=en&populate%5Bhotel_groups%5D%5Bpopulate%5D%5B0%5D=hotels&populate%5Bbanner%5D=true&populate%5Bhotels%5D=true&populate%5Bseo%5D%5Bpopulate%5D%5B0%5D=openGraph
        run: |
          node - <<'NODE'
          import fs from 'node:fs';

          const URL = process.env.SOURCE_URL;

          const res = await fetch(URL);
          if (!res.ok) {
            console.error('Upstream error:', res.status, await res.text());
            process.exit(1);
          }
          const json = await res.json();

          let items = toSaleItems(json);
          if (!items.length) {
            console.warn('Primary extractor found 0 items, running deep fallback scan…');
            items = uniqueByObjectID(
              deepScanForHotels(json)        // only objects that have a propId-like key
                .map(pickSaleFields)         // returns null if no propId
                .filter(Boolean)
            );
          }

          // Never overwrite with [] — only write when we found items
          if (!items.length) {
            console.warn('Extractor produced 0 items. Leaving hotel_sales.json unchanged.');
            process.exit(0);
          }

          fs.writeFileSync('hotel_sales.json', JSON.stringify(items, null, 2));
          console.log(`Wrote ${items.length} items to hotel_sales.json`);

          // ---------- helpers ----------
          function toSaleItems(json) {
            if (Array.isArray(json)) return json.map(pickSaleFields).filter(Boolean);
            const { data } = json || {};
            if (!data) return [];
            if (data?.attributes) return extractFromEntity(data);
            if (Array.isArray(data)) return data.flatMap(extractFromEntity);
            return [];
          }

          function extractFromEntity(entity) {
            const a = entity?.attributes || {};
            const direct = Array.isArray(a.hotels) ? a.hotels : [];
            const rel    = a.hotels?.data ?? [];
            const groups = a.hotel_groups?.data ?? a.hotel_groups ?? [];
            const fromGroups = groups.flatMap(g => {
              const ga = g?.attributes || {};
              const h1 = Array.isArray(ga.hotels) ? ga.hotels : [];
              const h2 = ga.hotels?.data ?? [];
              return [...h1, ...h2];
            });

            const candidates = [...normalize(direct), ...normalize(rel), ...normalize(fromGroups)];
            const seen = new Set();
            const out = [];
            for (const mapped of candidates.map(pickSaleFields).filter(Boolean)) {
              if (seen.has(mapped.objectID)) continue;
              seen.add(mapped.objectID);
              out.push(mapped);
            }
            return out; // only real hotels with propId
          }

          function normalize(arr) {
            return (arr || []).map(n =>
              (n && typeof n === 'object' && 'attributes' in n)
                ? { id: n.id, ...n.attributes }
                : n
            );
          }

          // Fallback: recursively scan for objects that LOOK like hotels
          // (must have a propId-like key; names like "USA & CANADA" won't pass)
          function deepScanForHotels(obj, bucket = []) {
            if (!obj || typeof obj !== 'object') return bucket;
            if (Array.isArray(obj)) { obj.forEach(o => deepScanForHotels(o, bucket)); return bucket; }
            const hasPid = ('propId' in obj) || ('prop_id' in obj) || ('propertyId' in obj);
            if (hasPid) bucket.push(obj);
            for (const k of Object.keys(obj)) deepScanForHotels(obj[k], bucket);
            return bucket;
          }

          function uniqueByObjectID(arr) {
            const seen = new Set();
            const out = [];
            for (const it of arr) {
              const oid = String(it.objectID);
              if (!oid || seen.has(oid)) continue;
              seen.add(oid);
              out.push(it);
            }
            return out;
          }

          // ✅ Only keep entries that have a property id; skip groups/banners/regions
          function pickSaleFields(src) {
            const pid = src.propId ?? src.prop_id ?? src.propertyId;
            if (pid == null) return null; // not a hotel
            return {
              objectID: String(pid),
              member_sale: src.member_sale ?? null,
              offer_valid_until: src.offer_valid_until ?? null,
              sale_ends: src.sale_ends ?? null,
              location: src.location ?? null,
              description: src.description ?? null,
              // optional extras
              name: src.name ?? null,
              propId_or_name: src.propId_or_name ?? null,
              for_migration: src.for_migration ?? null,
            };
          }
          NODE
