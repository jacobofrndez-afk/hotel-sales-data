name: Publish hotel_sales.json

on:
  schedule:
    - cron: '0 */4 * * *'   # every 4 hours UTC
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Generate hotel_sales.json
        env:
          SOURCE_URL: >-
            https://strapi.prod.r53.tablethotels.com/api/hotels-on-sale-page?pagination%5BpageSize%5D=1000&locale=en&populate%5Bhotel_groups%5D%5Bpopulate%5D%5B0%5D=hotels&populate%5Bbanner%5D=true&populate%5Bhotels%5D=true&populate%5Bseo%5D%5Bpopulate%5D%5B0%5D=openGraph
        run: |
          node - <<'NODE'
          import fs from 'node:fs';

          const URL = process.env.SOURCE_URL;

          const res = await fetch(URL);
          if (!res.ok) {
            console.error('Upstream error:', res.status, await res.text());
            process.exit(1);
          }
          const json = await res.json();

          let items = toSaleItems(json);
          if (!items.length) {
            console.warn('Primary extractor found 0 items, running deep fallback scan…');
            items = uniqueByObjectID(deepScanForHotels(json).map(pickSaleFields));
          }

          // Never overwrite with [] — only write when we found items
          if (!items.length) {
            console.warn('Extractor produced 0 items. Leaving hotel_sales.json unchanged.');
            process.exit(0);
          }

          fs.writeFileSync('hotel_sales.json', JSON.stringify(items, null, 2));
          console.log(`Wrote ${items.length} items to hotel_sales.json`);

          // ---------- helpers ----------
          function toSaleItems(json) {
            if (Array.isArray(json)) return json.map(pickSaleFields);
            const { data } = json || {};
            if (!data) return [];
            if (data?.attributes) return extractFromEntity(data);
            if (Array.isArray(data)) return data.flatMap(extractFromEntity);
            return [];
          }

          function extractFromEntity(entity) {
            const a = entity?.attributes || {};
            const direct = Array.isArray(a.hotels) ? a.hotels : [];
            const rel    = a.hotels?.data ?? [];
            const groups = a.hotel_groups?.data ?? a.hotel_groups ?? [];
            const fromGroups = groups.flatMap(g => {
              const ga = g?.attributes || {};
              const h1 = Array.isArray(ga.hotels) ? ga.hotels : [];
              const h2 = ga.hotels?.data ?? [];
              return [...h1, ...h2];
            });

            const candidates = [...normalize(direct), ...normalize(rel), ...normalize(fromGroups)];
            const seen = new Set();
            const out = [];
            for (const it of candidates) {
              const pid = it.propId ?? it.prop_id ?? it.propertyId ?? it.id;
              const key = pid != null ? `p:${pid}` : `i:${it.id ?? Math.random()}`;
              if (seen.has(key)) continue;
              seen.add(key);
              out.push(pickSaleFields(it));
            }
            return out.filter(x => x.objectID);
          }

          function normalize(arr) {
            return (arr || []).map(n =>
              (n && typeof n === 'object' && 'attributes' in n)
                ? { id: n.id, ...n.attributes }
                : n
            );
          }

          // Fallback: recursively scan for objects that look like hotel records
          function deepScanForHotels(obj, bucket = []) {
            if (!obj || typeof obj !== 'object') return bucket;
            if (Array.isArray(obj)) { obj.forEach(o => deepScanForHotels(o, bucket)); return bucket; }
            const hasId = ('propId' in obj) || ('prop_id' in obj) || ('propertyId' in obj) || ('id' in obj);
            const hasNameOrSale = ('name' in obj) || ('member_sale' in obj) || ('offer_valid_until' in obj) || ('sale_ends' in obj);
            if (hasId && hasNameOrSale) bucket.push(obj);
            for (const k of Object.keys(obj)) deepScanForHotels(obj[k], bucket);
            return bucket;
          }

          function uniqueByObjectID(arr) {
            const seen = new Set();
            const out = [];
            for (const it of arr) {
              const oid = String(it.objectID ?? it.propId ?? it.prop_id ?? it.propertyId ?? it.id ?? '');
              if (!oid || seen.has(oid)) continue;
              seen.add(oid);
              out.push({ ...it, objectID: oid });
            }
            return out;
          }

          function pickSaleFields(src) {
            const objectID = String(src.objectID ?? src.propId ?? src.prop_id ?? src.propertyId ?? src.id ?? '');
            return {
              objectID,
              member_sale: src.member_sale ?? null,
              offer_valid_until: src.offer_valid_until ?? null,
              sale_ends: src.sale_ends ?? null,
              location: src.location ?? null,
              description: src.description ?? null,
              name: src.name ?? null,
              propId_or_name: src.propId_or_name ?? null,
              for_migration: src.for_migration ?? null,
            };
          }
          NODE

      - name: Commit & push if changed
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          if [[ -n "$(git status --porcelain)" ]]; then
            git add hotel_sales.json
            git commit -m "Update hotel_sales.json ($(date -u +'%Y-%m-%d %H:%M:%S') UTC)"
            git push origin main
          else
            echo "No changes to commit."
          fi
