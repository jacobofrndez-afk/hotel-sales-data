      - name: Generate hotel_sales.json
        env:
          SOURCE_URL: >-
            https://strapi.prod.r53.tablethotels.com/api/hotels-on-sale-page?pagination%5BpageSize%5D=1000&locale=en&populate%5Bhotel_groups%5D%5Bpopulate%5D%5B0%5D=hotels&populate%5Bbanner%5D=true&populate%5Bhotels%5D=true&populate%5Bseo%5D%5Bpopulate%5D%5B0%5D=openGraph
        run: |
          node - <<'NODE'
          import fs from 'node:fs';

          const URL = process.env.SOURCE_URL;

          const res = await fetch(URL);
          if (!res.ok) {
            console.error('Upstream error:', res.status, await res.text());
            process.exit(1);
          }
          const json = await res.json();

          // ---- Try structured extraction, then a deep fallback scan ----
          let items = toSaleItems(json);
          if (!items.length) {
            console.warn('Primary extractor found 0 items, running deep fallback scanâ€¦');
            items = uniqueByObjectID(deepScanForHotels(json).map(pickSaleFields));
          }

          // ---- Print a compact debug summary to the logs ----
          console.log('DEBUG summary:', JSON.stringify(summarize(json, items.length), null, 2));

          // ---- Guard: never overwrite with [] ----
          if (!items.length) {
            console.warn('Extractor produced 0 items. Leaving hotel_sales.json unchanged.');
            process.exit(0); // no commit happens if nothing changed
          }

          fs.writeFileSync('hotel_sales.json', JSON.stringify(items, null, 2));
          console.log(`Wrote ${items.length} items to hotel_sales.json`);

          // ------- helpers --------
          function toSaleItems(json) {
            if (Array.isArray(json)) return json.map(pickSaleFields);
            const { data } = json || {};
            if (!data) return [];
            if (data?.attributes) return extractFromEntity(data);
            if (Array.isArray(data)) return data.flatMap(extractFromEntity);
            return [];
          }

          function extractFromEntity(entity) {
            const a = entity?.attributes || {};
            const direct = Array.isArray(a.hotels) ? a.hotels : [];
            const rel    = a.hotels?.data ?? [];
            const groups = a.hotel_groups?.data ?? a.hotel_groups ?? [];
            const fromGroups = groups.flatMap(g => {
              const ga = g?.attributes || {};
              const h1 = Array.isArray(ga.hotels) ? ga.hotels : [];
              const h2 = ga.hotels?.data ?? [];
              return [...h1, ...h2];
            });

            const candidates = [...normalize(direct), ...normalize(rel), ...normalize(fromGroups)];
            const seen = new Set();
            const out = [];
            for (const it of candidates) {
              const pid = it.propId ?? it.prop_id ?? it.propertyId ?? it.id;
              const key = pid != null ? `p:${pid}` : `i:${it.id ?? Math.random()}`;
              if (seen.has(key)) continue;
              seen.add(key);
              out.push(pickSaleFields(it));
            }
            return out.filter(x => x.objectID); // require objectID
          }

          function normalize(arr) {
            return (arr || []).map(n => (n && typeof n === 'object' && 'attributes' in n)
              ? { id: n.id, ...n.attributes }
              : n);
          }

          // Fallback: recursively scan for objects that look like hotel records
          function deepScanForHotels(obj, bucket = []) {
            if (!obj || typeof obj !== 'object') return bucket;
            if (Array.isArray(obj)) { obj.forEach(o => deepScanForHotels(o, bucket)); return bucket; }
            const keys = Object.keys(obj);
            const hasId = ('propId' in obj) || ('prop_id' in obj) || ('propertyId' in obj) || ('id' in obj);
            const hasNameOrSale = ('name' in obj) || ('member_sale' in obj) || ('offer_valid_until' in obj) || ('sale_ends' in obj);
            if (hasId && hasNameOrSale) bucket.push(obj);
            for (const k of keys) deepScanForHotels(obj[k], bucket);
            return bucket;
          }

          function uniqueByObjectID(arr) {
            const seen = new Set();
            const out = [];
            for (const it of arr) {
              const oid = String(it.objectID ?? it.propId ?? it.prop_id ?? it.propertyId ?? it.id ?? '');
              if (!oid) continue;
              if (seen.has(oid)) continue;
              seen.add(oid);
              out.push({ ...it, objectID: oid });
            }
            return out;
          }

          function pickSaleFields(src) {
            const objectID = String(src.objectID ?? src.propId ?? src.prop_id ?? src.propertyId ?? src.id ?? '');
            return {
              objectID,
              member_sale: src.member_sale ?? null,
              offer_valid_until: src.offer_valid_until ?? null,
              sale_ends: src.sale_ends ?? null,
              location: src.location ?? null,
              description: src.description ?? null,
              // optional extras (kept if present)
              name: src.name ?? null,
              propId_or_name: src.propId_or_name ?? null,
              for_migration: src.for_migration ?? null,
            };
          }

          function summarize(json, foundCount) {
            const d = json?.data;
            const a = d?.attributes;
            return {
              foundCount,
              hasData: !!d,
              dataIsArray: Array.isArray(d),
              attrKeys: a ? Object.keys(a).slice(0, 20) : [],
              hotelsArrayLen: Array.isArray(a?.hotels) ? a.hotels.length : 0,
              hotelsRelLen: Array.isArray(a?.hotels?.data) ? a.hotels.data.length : 0,
              groupCount: Array.isArray(a?.hotel_groups?.data) ? a.hotel_groups.data.length
                         : (Array.isArray(a?.hotel_groups) ? a.hotel_groups.length : 0),
            };
          }
          NODE
